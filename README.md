[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18373775&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
 The systematic application of engineering principles, methods and tools to the development and maintenace of high quality software systems
Identify and describe at least three key milestones in the evolution of software engineering.
The Establishment of software engineering as a discipline in 1960s
The development of programming languages e.g Fortran
Advent of structured programming in the 1970
The rise of Agile methodologies in the 2000s

List and briefly explain the phases of the Software Development Life Cycle.
Requirement – Gathering and documenting user needs and requirements

Design – creating high-level and detailed designs of the software architecture and user interface
Implementation – Writing code and building the software according to the design specifications

Testing – The software undergoes rigorous testing (unit, integration, system, and user acceptance testing) to identify and fix defects, ensuring it meets requirements.

Deployment – Releasing the software to users or customers

Maintenance & Support – Providing ongoing support updates and enhancement to the software after development

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
The Waterfall methodology follows a linear, sequential approach where development progresses through fixed phases (requirements, design, development, testing, and deployment), making it ideal for projects with stable requirements, such as banking systems. In contrast, Agile is iterative and flexible, allowing continuous collaboration and frequent deliveries, making it suitable for dynamic projects like mobile app development. Waterfall limits changes once the project starts, while Agile adapts to evolving requirements. Agile involves ongoing testing and stakeholder feedback, whereas Waterfall testing occurs at the end. Ultimately, Waterfall suits well-defined, structured projects, while Agile thrives in fast-changing environments requiring adaptability.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
Software Developer
Responsible for writing code and implementing software solutions

Quality Assurance Engineer
Ensures software quality by designing and executing test plans

Project Manager
Oversees the planning, execution and delivery of software projects

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
Integrated Development Environments (IDEs)
IDEs are essential tools that provide a comprehensive workspace for writing, debugging, and testing code, improving developer productivity. They offer features like syntax highlighting, code completion, debugging tools, and integrated build systems. For example, Visual Studio Code supports multiple programming languages with extensions, while IntelliJ IDEA is widely used for Java development. IDEs streamline development by reducing errors and improving code efficiency.

Version Control Systems (VCS)
VCS helps teams track and manage changes to code over time, enabling collaboration, rollback, and conflict resolution. It ensures code integrity, facilitates teamwork, and allows developers to revert to previous versions if needed. For example, Git, along with platforms like GitHub and GitLab, allows distributed development and version tracking. Apache Subversion (SVN) is another VCS used in enterprise environments for centralized version control.

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
Changing Requirements - Regular reassessment of project goals and timelines
Tight Deadlines- Prioritization of tasks
Technical Debt - Implementing strategic approach that balances short-term development needs with long-term system maintainability.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
Unit Testing – Involves testing individual components or functions of the software in isolation to ensure they work as expected.
Importance: Detects bugs early, improves code quality, and simplifies debugging.
Example: Testing a login function to ensure it correctly validates user credentials.

Integration Testing – Focuses on verifying the interactions between different modules or components to ensure they work together correctly.
Importance: Identifies issues in data flow and communication between integrated components.
Example: Checking if a payment module correctly interacts with the order processing system.

System Testing – Evaluates the complete software system as a whole to ensure it meets the specified requirements.
Importance: Ensures overall system functionality, performance, security, and compliance.
Example: Running tests on an e-commerce website to verify smooth user navigation and transaction processing.

Acceptance Testing – Conducted to determine whether the software meets business requirements and is ready for deployment.
Importance: Validates that the software fulfills user needs and expectations.
Example: A client testing a newly developed CRM system to confirm it supports their business processes.

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is the process of designing and refining input queries to effectively interact with AI models and achieve accurate, relevant responses. It plays a crucial role in improving AI accuracy, optimizing efficiency, expanding capabilities, and enhancing user experience. Well-structured prompts help AI understand tasks better, reducing errors and making interactions more intuitive.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
Vague Prompt:
"Tell me about technology."

Improved Prompt:
"Explain how artificial intelligence is transforming the healthcare industry, with examples of its applications in diagnosis and treatment."

Why the Improved Prompt is More Effective:
The original prompt is too broad and lacks direction, making it difficult for AI to provide a focused response. The improved prompt is clear (specific topic: AI in healthcare), specific (focus on diagnosis and treatment), and concise (structured request). This ensures a more relevant and informative response tailored to the user’s needs.
